# 배포 사용자 설정 가이드

> **목적**: LifeBit 프로젝트의 완전 무인 배포를 위해 사용자가 반드시 설정해야 하는 작업들을 정리한 문서입니다.

## 📋 개요

이 문서는 **완전한 무인 배포/운영**을 위해 사람이 **1회성으로 반드시 수행**해야 하는 설정 작업들을 단계별로 안내합니다. 모든 설정 완료 후에는 GitHub 푸시만으로 전체 배포가 자동화됩니다.

---

## 🎯 설정 완료 후 달성 목표

- ✅ **코드 푸시** → **자동 테스트** → **자동 배포** → **자동 모니터링** → **자동 롤백**(필요시)
- ✅ **24/7 무인 운영** 가능
- ✅ **장애 자동 감지** 및 **복구**
- ✅ **비용 최적화** 자동 적용

---

## 1. 📋 사전 준비 체크리스트

### 1.1 필수 계정 및 서비스
- [ ] **AWS 계정** (결제 정보 등록 완료)
- [ ] **도메인** (구매 또는 보유)
- [ ] **GitHub 계정** (리포지토리 관리자 권한)
- [ ] **OpenAI API 계정** (GPT 사용을 위한 API 키)
- [ ] **카카오 개발자 계정** (소셜 로그인용)
- [ ] **구글 개발자 계정** (소셜 로그인용)

### 1.2 로컬 개발 환경
- [ ] **AWS CLI** 설치 및 설정
- [ ] **Terraform** 설치 (v1.0+)
- [ ] **Ansible** 설치 (v2.9+)
- [ ] **Docker & Docker Compose** 설치
- [ ] **Node.js** 18+ 및 **pnpm** 설치
- [ ] **Java 21** 설치
- [ ] **Python 3.11+** 설치

---

## 2. 🔐 AWS 계정 및 권한 설정

### 2.1 AWS IAM 사용자 생성
```bash
# AWS 콘솔에서 IAM 사용자 생성
# 사용자명: lifebit-deploy-user
# 액세스 유형: 프로그래밍 방식 액세스
```

### 2.2 필요 권한 정책 연결
```json
{
  "필수 권한": [
    "AmazonEC2FullAccess",
    "AmazonRDSFullAccess",
    "AmazonS3FullAccess",
    "AmazonRoute53FullAccess",
    "IAMFullAccess",
    "AmazonVPCFullAccess",
    "ElasticLoadBalancingFullAccess",
    "AmazonECS_FullAccess",
    "CloudWatchFullAccess"
  ]
}
```

### 2.3 AWS CLI 설정
```bash
# 터미널에서 실행
aws configure

# 입력 정보:
# AWS Access Key ID: [IAM 사용자 액세스 키]
# AWS Secret Access Key: [IAM 사용자 시크릿 키]
# Default region name: ap-northeast-2
# Default output format: json

# 설정 확인
aws sts get-caller-identity
```

### 2.4 SSH 키페어 생성
```bash
# AWS 콘솔 → EC2 → 키 페어
# 키 페어 이름: lifebit-keypair
# 키 페어 유형: RSA
# 프라이빗 키 파일 형식: .pem

# 다운로드한 키 파일 권한 설정
chmod 400 ~/.ssh/lifebit-keypair.pem
```

---

## 3. 🌐 도메인 및 DNS 설정

### 3.1 도메인 구매 (선택사항)
```bash
# 추천 도메인 등록업체:
# - AWS Route 53
# - 가비아
# - 후이즈
# - Cloudflare

# 예시 도메인: your-project.com
```

### 3.2 Route 53 호스팅 영역 생성
```bash
# AWS 콘솔 → Route 53 → 호스팅 영역 생성
# 도메인 이름: your-project.com
# 유형: 퍼블릭 호스팅 영역

# 네임서버 정보를 도메인 등록업체에 설정
```

### 3.3 DNS 레코드 준비 (배포 후 자동 설정됨)
```bash
# 다음 레코드들이 자동으로 생성됩니다:
# A 레코드: your-project.com → EC2 인스턴스 IP
# CNAME: api.your-project.com → your-project.com
# CNAME: www.your-project.com → your-project.com
```

---

## 4. 🔑 환경 변수 및 비밀 정보 설정

### 4.1 루트 .env 파일 생성
```bash
# 프로젝트 루트에 .env 파일 생성
cp .env.example .env
```

```env
# .env 파일 내용
# AWS 설정
AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=...
AWS_REGION=ap-northeast-2
AWS_ACCOUNT_ID=123456789012

# 도메인 설정
DOMAIN_NAME=your-project.com
SUBDOMAIN_API=api.your-project.com
SUBDOMAIN_WWW=www.your-project.com

# 데이터베이스 설정
DB_NAME=lifebit_db
DB_USER=lifebit_user
DB_PASSWORD=your-secure-password-here
DB_HOST=localhost
DB_PORT=5432

# OpenAI API
OPENAI_API_KEY=sk-...

# 소셜 로그인
KAKAO_CLIENT_ID=your-kakao-client-id
KAKAO_CLIENT_SECRET=your-kakao-client-secret
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# JWT 설정
JWT_SECRET=your-jwt-secret-key-here
JWT_EXPIRATION=86400

# 기타 설정
ENVIRONMENT=production
LOG_LEVEL=info
```

### 4.2 각 서비스별 환경 변수 설정
```bash
# AI API 환경 변수
cp apps/ai-api-fastapi/.env.example apps/ai-api-fastapi/.env

# Frontend 환경 변수
cp apps/frontend-vite/.env.example apps/frontend-vite/.env
```

### 4.3 GitHub Secrets 설정
```bash
# GitHub Repository → Settings → Secrets and variables → Actions
# 다음 시크릿들을 추가:

AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=...
AWS_REGION=ap-northeast-2
DOMAIN_NAME=your-project.com
DB_PASSWORD=your-secure-password
OPENAI_API_KEY=sk-...
KAKAO_CLIENT_ID=your-kakao-client-id
KAKAO_CLIENT_SECRET=your-kakao-client-secret
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
JWT_SECRET=your-jwt-secret-key
```

---

## 5. 🏗️ 인프라 코드 생성

### 5.1 Terraform 코드 생성
```bash
# infrastructure/terraform 디렉토리 생성
mkdir -p infrastructure/terraform
```

**infrastructure/terraform/main.tf**
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC 생성
resource "aws_vpc" "lifebit_vpc" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name    = "lifebit-vpc"
    Project = "LifeBit"
  }
}

# 인터넷 게이트웨이
resource "aws_internet_gateway" "lifebit_igw" {
  vpc_id = aws_vpc.lifebit_vpc.id

  tags = {
    Name    = "lifebit-igw"
    Project = "LifeBit"
  }
}

# 퍼블릭 서브넷
resource "aws_subnet" "lifebit_public_subnet" {
  vpc_id                  = aws_vpc.lifebit_vpc.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "${var.aws_region}a"
  map_public_ip_on_launch = true

  tags = {
    Name    = "lifebit-public-subnet"
    Project = "LifeBit"
  }
}

# 라우팅 테이블
resource "aws_route_table" "lifebit_public_rt" {
  vpc_id = aws_vpc.lifebit_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.lifebit_igw.id
  }

  tags = {
    Name    = "lifebit-public-rt"
    Project = "LifeBit"
  }
}

resource "aws_route_table_association" "lifebit_public_rta" {
  subnet_id      = aws_subnet.lifebit_public_subnet.id
  route_table_id = aws_route_table.lifebit_public_rt.id
}

# 보안 그룹
resource "aws_security_group" "lifebit_sg" {
  name        = "lifebit-security-group"
  description = "Security group for LifeBit application"
  vpc_id      = aws_vpc.lifebit_vpc.id

  # SSH
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # HTTP
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # HTTPS
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # Application ports
  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
  }

  ingress {
    from_port   = 8001
    to_port     = 8001
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name    = "lifebit-sg"
    Project = "LifeBit"
  }
}

# EC2 인스턴스
resource "aws_instance" "lifebit_server" {
  ami                    = "ami-0c2d3e23c4f7c8f8c" # Amazon Linux 2023
  instance_type          = "t3.medium"
  key_name               = var.key_pair_name
  vpc_security_group_ids = [aws_security_group.lifebit_sg.id]
  subnet_id              = aws_subnet.lifebit_public_subnet.id

  root_block_device {
    volume_type = "gp3"
    volume_size = 20
    encrypted   = true
  }

  user_data = file("${path.module}/user-data.sh")

  tags = {
    Name    = "lifebit-server"
    Project = "LifeBit"
  }
}

# Elastic IP
resource "aws_eip" "lifebit_eip" {
  instance = aws_instance.lifebit_server.id
  domain   = "vpc"

  tags = {
    Name    = "lifebit-eip"
    Project = "LifeBit"
  }
}
```

**infrastructure/terraform/variables.tf**
```hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "ap-northeast-2"
}

variable "domain_name" {
  description = "Domain name for the application"
  type        = string
}

variable "key_pair_name" {
  description = "AWS Key Pair name"
  type        = string
  default     = "lifebit-keypair"
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
```

**infrastructure/terraform/outputs.tf**
```hcl
output "instance_ip" {
  description = "Public IP address of the instance"
  value       = aws_eip.lifebit_eip.public_ip
}

output "instance_dns" {
  description = "Public DNS name of the instance"
  value       = aws_instance.lifebit_server.public_dns
}

output "vpc_id" {
  description = "VPC ID"
  value       = aws_vpc.lifebit_vpc.id
}
```

**infrastructure/terraform/user-data.sh**
```bash
#!/bin/bash
yum update -y
yum install -y docker git

# Docker 시작
systemctl start docker
systemctl enable docker
usermod -a -G docker ec2-user

# Docker Compose 설치
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# 애플리케이션 디렉토리 생성
mkdir -p /opt/lifebit
chown ec2-user:ec2-user /opt/lifebit
```

### 5.2 Ansible 플레이북 생성
```bash
# infrastructure/ansible 디렉토리 생성
mkdir -p infrastructure/ansible/{inventory,group_vars,roles/{common,docker,nginx,postgresql,ssl,deploy}/tasks}
```

**infrastructure/ansible/inventory/hosts.yml**
```yaml
all:
  hosts:
    lifebit_server:
      ansible_host: "{{ server_ip }}"
      ansible_user: ec2-user
      ansible_ssh_private_key_file: ~/.ssh/lifebit-keypair.pem
  vars:
    ansible_python_interpreter: /usr/bin/python3
```

**infrastructure/ansible/group_vars/all.yml**
```yaml
# 프로젝트 설정
project_name: lifebit
project_dir: /opt/lifebit
app_user: ec2-user

# 도메인 설정
domain_name: "{{ lookup('env', 'DOMAIN_NAME') }}"
api_subdomain: "api.{{ domain_name }}"

# 데이터베이스 설정
db_name: "{{ lookup('env', 'DB_NAME') }}"
db_user: "{{ lookup('env', 'DB_USER') }}"
db_password: "{{ lookup('env', 'DB_PASSWORD') }}"

# SSL 설정
ssl_email: "admin@{{ domain_name }}"
```

**infrastructure/ansible/playbook.yml**
```yaml
---
- name: Deploy LifeBit Application
  hosts: all
  become: yes
  roles:
    - common
    - docker
    - postgresql
    - nginx
    - ssl
    - deploy
```

### 5.3 배포 스크립트 생성
```bash
mkdir -p infrastructure/scripts
```

**infrastructure/scripts/deploy.sh**
```bash
#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"
TERRAFORM_DIR="$ROOT_DIR/infrastructure/terraform"
ANSIBLE_DIR="$ROOT_DIR/infrastructure/ansible"

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# 환경 변수 로드
if [[ -f "$ROOT_DIR/.env" ]]; then
    source "$ROOT_DIR/.env"
    log_info "환경 변수 로드 완료"
else
    log_error ".env 파일을 찾을 수 없습니다"
    exit 1
fi

# Terraform 배포
deploy_terraform() {
    log_info "Terraform 인프라 배포 시작..."
    cd "$TERRAFORM_DIR"
    
    terraform init
    terraform plan -var="domain_name=$DOMAIN_NAME" -var="db_password=$DB_PASSWORD"
    terraform apply -var="domain_name=$DOMAIN_NAME" -var="db_password=$DB_PASSWORD" -auto-approve
    
    # 인스턴스 IP 추출
    export SERVER_IP=$(terraform output -raw instance_ip)
    log_info "인스턴스 IP: $SERVER_IP"
    
    cd "$ROOT_DIR"
}

# Ansible 배포
deploy_ansible() {
    log_info "Ansible 서버 설정 시작..."
    cd "$ANSIBLE_DIR"
    
    # 인벤토리 파일에 IP 주입
    sed -i "s/{{ server_ip }}/$SERVER_IP/g" inventory/hosts.yml
    
    # SSH 연결 대기
    log_info "SSH 연결 대기 중..."
    while ! ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i ~/.ssh/lifebit-keypair.pem ec2-user@$SERVER_IP 'echo "SSH 연결 성공"' 2>/dev/null; do
        echo "SSH 연결 대기 중..."
        sleep 10
    done
    
    # Ansible 플레이북 실행
    ansible-playbook -i inventory/hosts.yml playbook.yml
    
    cd "$ROOT_DIR"
}

# 헬스 체크
health_check() {
    log_info "서비스 헬스 체크 시작..."
    
    # 최대 5분 대기
    for i in {1..30}; do
        if curl -f "http://$DOMAIN_NAME" >/dev/null 2>&1; then
            log_info "✅ 웹사이트 정상 작동 확인"
            break
        fi
        
        if [[ $i -eq 30 ]]; then
            log_error "❌ 헬스 체크 실패"
            exit 1
        fi
        
        echo "헬스 체크 대기 중... ($i/30)"
        sleep 10
    done
}

# 메인 실행
main() {
    log_info "🚀 LifeBit 자동 배포 시작"
    
    case "${1:-all}" in
        terraform-only)
            deploy_terraform
            ;;
        ansible-only)
            if [[ -z "$SERVER_IP" ]]; then
                SERVER_IP=$(cd "$TERRAFORM_DIR" && terraform output -raw instance_ip)
            fi
            deploy_ansible
            ;;
        all)
            deploy_terraform
            deploy_ansible
            health_check
            ;;
        *)
            log_error "사용법: $0 [terraform-only|ansible-only|all]"
            exit 1
            ;;
    esac
    
    log_info "🎉 배포 완료!"
    log_info "🌐 웹사이트: https://$DOMAIN_NAME"
    log_info "📊 API: https://api.$DOMAIN_NAME"
}

main "$@"
```

**infrastructure/scripts/rollback.sh**
```bash
#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# 환경 변수 로드
if [[ -f "$ROOT_DIR/.env" ]]; then
    source "$ROOT_DIR/.env"
else
    log_error ".env 파일을 찾을 수 없습니다"
    exit 1
fi

# 서버 IP 가져오기
get_server_ip() {
    cd "$ROOT_DIR/infrastructure/terraform"
    SERVER_IP=$(terraform output -raw instance_ip 2>/dev/null || echo "")
    
    if [[ -z "$SERVER_IP" ]]; then
        log_error "서버 IP를 찾을 수 없습니다"
        exit 1
    fi
    
    log_info "서버 IP: $SERVER_IP"
}

# 이전 버전으로 롤백
rollback_services() {
    log_info "서비스 롤백 시작..."
    
    ssh -i ~/.ssh/lifebit-keypair.pem ec2-user@$SERVER_IP << 'EOF'
        cd /opt/lifebit
        
        # 현재 컨테이너 중지
        docker-compose down
        
        # 이전 이미지로 태그 변경
        docker tag lifebit_frontend:current lifebit_frontend:rollback
        docker tag lifebit_frontend:previous lifebit_frontend:current
        docker tag lifebit_core_api:current lifebit_core_api:rollback
        docker tag lifebit_core_api:previous lifebit_core_api:current
        docker tag lifebit_ai_api:current lifebit_ai_api:rollback
        docker tag lifebit_ai_api:previous lifebit_ai_api:current
        
        # 서비스 재시작
        docker-compose up -d
        
        echo "롤백 완료"
EOF
}

# 헬스 체크
health_check() {
    log_info "롤백 후 헬스 체크..."
    
    sleep 30
    
    if curl -f "http://$DOMAIN_NAME" >/dev/null 2>&1; then
        log_info "✅ 롤백 성공 - 서비스 정상 작동"
    else
        log_error "❌ 롤백 후에도 서비스 문제 발생"
        exit 1
    fi
}

# 메인 실행
main() {
    log_info "🔄 LifeBit 서비스 롤백 시작"
    
    get_server_ip
    rollback_services
    health_check
    
    log_info "🎉 롤백 완료!"
}

main "$@"
```

**infrastructure/scripts/health-check.sh**
```bash
#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# 환경 변수 로드
if [[ -f "$ROOT_DIR/.env" ]]; then
    source "$ROOT_DIR/.env"
else
    log_error ".env 파일을 찾을 수 없습니다"
    exit 1
fi

# 웹사이트 헬스 체크
check_website() {
    if curl -f -s "https://$DOMAIN_NAME" >/dev/null; then
        log_info "✅ 웹사이트 정상"
        return 0
    else
        log_error "❌ 웹사이트 접속 불가"
        return 1
    fi
}

# API 헬스 체크
check_api() {
    if curl -f -s "https://api.$DOMAIN_NAME/actuator/health" >/dev/null; then
        log_info "✅ Core API 정상"
        api_status=0
    else
        log_error "❌ Core API 접속 불가"
        api_status=1
    fi
    
    if curl -f -s "https://api.$DOMAIN_NAME/health" >/dev/null; then
        log_info "✅ AI API 정상"
        ai_status=0
    else
        log_error "❌ AI API 접속 불가"
        ai_status=1
    fi
    
    return $((api_status + ai_status))
}

# 데이터베이스 헬스 체크
check_database() {
    cd "$ROOT_DIR/infrastructure/terraform"
    SERVER_IP=$(terraform output -raw instance_ip 2>/dev/null || echo "")
    
    if [[ -z "$SERVER_IP" ]]; then
        log_error "서버 IP를 찾을 수 없습니다"
        return 1
    fi
    
    db_check=$(ssh -i ~/.ssh/lifebit-keypair.pem ec2-user@$SERVER_IP \
        "docker exec lifebit_postgres pg_isready -U $DB_USER -d $DB_NAME" 2>/dev/null || echo "failed")
    
    if [[ "$db_check" == *"accepting connections"* ]]; then
        log_info "✅ 데이터베이스 정상"
        return 0
    else
        log_error "❌ 데이터베이스 연결 불가"
        return 1
    fi
}

# 전체 헬스 체크
main() {
    log_info "🔍 LifeBit 서비스 헬스 체크 시작"
    
    failed=0
    
    check_website || ((failed++))
    check_api || ((failed++))
    check_database || ((failed++))
    
    if [[ $failed -eq 0 ]]; then
        log_info "🎉 모든 서비스 정상 작동"
        exit 0
    else
        log_error "⚠️ $failed 개 서비스에 문제 발생"
        exit 1
    fi
}

main "$@"
```

---

## 6. 🔧 CI/CD 파이프라인 설정

### 6.1 GitHub Actions 워크플로우 생성
```bash
mkdir -p .github/workflows
```

**.github/workflows/deploy.yml**
```yaml
name: Deploy LifeBit

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'pnpm'
    
    - name: Install dependencies
      run: pnpm install
    
    - name: Run tests
      run: pnpm test
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
    
    - name: Setup Ansible
      run: |
        pip install ansible
        ansible-galaxy install -r requirements.yml
    
    - name: Deploy Infrastructure
      run: |
        cd infrastructure/terraform
        terraform init
        terraform apply -auto-approve \
          -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}"
    
    - name: Deploy Application
      run: |
        export SERVER_IP=$(cd infrastructure/terraform && terraform output -raw instance_ip)
        cd infrastructure/ansible
        sed -i "s/{{ server_ip }}/$SERVER_IP/g" inventory/hosts.yml
        ansible-playbook -i inventory/hosts.yml playbook.yml
    
    - name: Health Check
      run: |
        sleep 60
        curl -f "https://${{ secrets.DOMAIN_NAME }}" || exit 1
        curl -f "https://api.${{ secrets.DOMAIN_NAME }}/actuator/health" || exit 1
```

---

## 7. 📊 모니터링 및 알림 설정

### 7.1 모니터링 설정 파일 생성
```bash
mkdir -p monitoring/{prometheus,grafana/dashboards,loki}
```

**monitoring/prometheus/prometheus.yml**
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'lifebit-core-api'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/actuator/prometheus'
  
  - job_name: 'lifebit-ai-api'
    static_configs:
      - targets: ['localhost:8001']
    metrics_path: '/metrics'
  
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['localhost:9100']
```

### 7.2 알림 설정 (Slack 웹훅)
```bash
# Slack 앱 생성 및 웹훅 URL 획득
# https://api.slack.com/apps → Create New App
# Incoming Webhooks → Activate → Add New Webhook
```

---

## 8. 🔒 보안 설정 체크리스트

### 8.1 JWT 시크릿 키 생성
```bash
# 강력한 JWT 시크릿 생성
openssl rand -base64 64

# 생성된 키를 .env 파일의 JWT_SECRET에 추가
```

### 8.2 데이터베이스 비밀번호 생성
```bash
# 강력한 DB 비밀번호 생성
openssl rand -base64 32

# 생성된 비밀번호를 .env 파일의 DB_PASSWORD에 추가
```

### 8.3 SSH 키 보안 설정
```bash
# SSH 키 파일 권한 설정
chmod 400 ~/.ssh/lifebit-keypair.pem

# SSH 설정 파일에 추가 (선택사항)
cat >> ~/.ssh/config << EOF
Host lifebit-server
    HostName your-server-ip
    User ec2-user
    IdentityFile ~/.ssh/lifebit-keypair.pem
    StrictHostKeyChecking no
EOF
```

---

## 9. 🧪 소셜 로그인 설정

### 9.1 카카오 개발자 계정 설정
```bash
# 1. https://developers.kakao.com 접속
# 2. 애플리케이션 추가하기
# 3. 앱 키 → REST API 키 복사
# 4. 플랫폼 설정 → Web → 도메인 등록: https://your-domain.com
# 5. 카카오 로그인 → 활성화 설정
# 6. Redirect URI 설정: https://your-domain.com/auth/kakao/callback
```

### 9.2 구글 개발자 계정 설정
```bash
# 1. https://console.developers.google.com 접속
# 2. 새 프로젝트 생성
# 3. API 및 서비스 → 사용자 인증 정보
# 4. OAuth 2.0 클라이언트 ID 생성
# 5. 승인된 리디렉션 URI: https://your-domain.com/auth/google/callback
# 6. 클라이언트 ID 및 시크릿 복사
```

---

## 10. ✅ 최종 배포 실행

### 10.1 설정 검증
```bash
# 모든 환경 변수 확인
source .env
echo "AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID:0:10}..."
echo "DOMAIN_NAME: $DOMAIN_NAME"
echo "DB_PASSWORD: ${DB_PASSWORD:0:5}..."
echo "OPENAI_API_KEY: ${OPENAI_API_KEY:0:10}..."

# AWS 연결 확인
aws sts get-caller-identity

# Terraform 설정 확인
cd infrastructure/terraform
terraform validate
```

### 10.2 첫 배포 실행
```bash
# 전체 배포 실행
chmod +x infrastructure/scripts/*.sh
./infrastructure/scripts/deploy.sh

# 또는 단계별 배포
./infrastructure/scripts/deploy.sh terraform-only
./infrastructure/scripts/deploy.sh ansible-only
```

### 10.3 배포 후 확인
```bash
# 헬스 체크 실행
./infrastructure/scripts/health-check.sh

# 수동 확인
curl -f "https://$DOMAIN_NAME"
curl -f "https://api.$DOMAIN_NAME/actuator/health"
```

---

## 🎉 완료 후 무인 운영

모든 설정이 완료되면 다음과 같은 **완전 무인 운영**이 가능합니다:

### ✅ 자동화된 작업들
- **코드 푸시** → **자동 테스트** → **자동 배포**
- **서비스 장애 감지** → **자동 재시작** → **Slack 알림**
- **SSL 인증서 자동 갱신** (Let's Encrypt)
- **데이터베이스 자동 백업** (일일 스냅샷)
- **로그 자동 수집** 및 **모니터링**
- **비용 알림** (AWS 예산 초과 시)

### 🔄 정기 관리 작업 (월 1회)
- **비용 리포트 검토**
- **보안 업데이트 확인**
- **백업 데이터 검증**
- **성능 메트릭 분석**

---

## 📞 문제 해결 및 지원

### 일반적인 문제들
1. **Terraform 오류**: `terraform destroy` 후 재배포
2. **SSH 연결 실패**: 보안 그룹 및 키페어 확인
3. **도메인 연결 실패**: DNS 전파 대기 (최대 48시간)
4. **SSL 인증서 오류**: Let's Encrypt 재발급

### 긴급 상황 대응
```bash
# 서비스 롤백
./infrastructure/scripts/rollback.sh

# 전체 인프라 삭제
./aws-cleanup.sh --force

# 헬스 체크
./infrastructure/scripts/health-check.sh
```

---

**🎯 이 가이드를 완료하면 GitHub에 코드만 푸시해도 전체 서비스가 자동으로 배포됩니다!**