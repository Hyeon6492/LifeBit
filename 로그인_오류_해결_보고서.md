# 🔧 LifeBit 로그인 400 에러 해결 보고서

## 📋 문제 개요
- **발생 일시**: 2025-06-17
- **오류 유형**: HTTP 400 Bad Request
- **영향 범위**: 사용자 로그인 기능 전체 불가
- **오류 메시지**: 
  ```
  :8080/api/auth/login:1 Failed to load resource: the server responded with a status of 400 ()
  axios.ts:37 Response error: Object
  auth.ts:48 Login failed: AxiosError
  ```

---

## 🔍 원인 분석

### 1️⃣ **주요 원인: 데이터베이스 연결 문제**
```yaml
# 문제가 된 설정 (application.yml)
spring:
  datasource:
    url: jdbc:h2:mem:testdb  # ❌ H2 인메모리 DB 사용
    username: sa
    password: 
    driver-class-name: org.h2.Driver
```

**문제점**: 
- 실제 PostgreSQL에 사용자 데이터가 있지만, 애플리케이션은 H2 인메모리 DB 사용
- H2는 애플리케이션 재시작 시 데이터 초기화됨
- 로그인 시 사용자 데이터를 찾을 수 없어 400 에러 발생

### 2️⃣ **부차적 원인들**

#### A. 환경 변수 미설정
```typescript
// 프론트엔드에서 API URL이 undefined일 가능성
export const API_CONFIG = {
    BASE_URL: import.meta.env.VITE_CORE_API_URL || 'http://localhost:8080',
    // ❌ .env 파일이 없어서 undefined 가능성
};
```

#### B. UserRepository 커스텀 쿼리 문제
```java
// 문제가 된 코드
@Query(value = """
    INSERT INTO users (email, nickname, password_hash, role, uuid, created_at, updated_at)
    VALUES (:email, :nickname, :passwordHash, CAST(:role AS user_role), :uuid, :createdAt, :updatedAt)
    RETURNING *
    """, nativeQuery = true)
User saveWithRole(...);  // ❌ 네이티브 쿼리로 인한 JPA 충돌 가능성
```

#### C. PostgreSQL 서버 미실행
- Docker Compose로 정의된 PostgreSQL이 실행되지 않은 상태
- 연결 시도 시 Connection Refused 발생

---

## 🛠️ 해결 조치 사항

### 1단계: 환경 변수 설정
```bash
# 생성된 파일: apps/frontend-vite/.env
VITE_CORE_API_URL=http://localhost:8080
VITE_AI_API_URL=http://localhost:8001
VITE_GOOGLE_CLIENT_ID=
VITE_KAKAO_CLIENT_ID=
```

**목적**: 프론트엔드에서 정확한 API URL 사용 보장

### 2단계: PostgreSQL 데이터베이스 복원
```yaml
# 수정된 application.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/lifebit_db  # ✅ PostgreSQL 연결
    username: lifebit_user
    password: lifebit_password
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate  # ✅ 기존 스키마 검증만 수행
```

**변경 사유**: 
- 실제 사용자 데이터가 있는 PostgreSQL 사용
- `validate` 모드로 기존 테이블 구조 보존

### 3단계: PostgreSQL 서버 실행
```bash
# Docker Compose로 PostgreSQL 실행
docker-compose up -d postgres-db

# 스키마 생성 (기존 테이블이 없을 경우)
docker exec -i lifebit_postgres psql -U lifebit_user -d lifebit_db < LifeBit.SQL
```

**결과**: 
- PostgreSQL 컨테이너 정상 실행
- 16개 테이블 생성 완료
- 사용자 데이터 7명 확인

### 4단계: UserRepository 최적화
```java
// 제거된 문제 코드
@Query(value = """
    INSERT INTO users (email, nickname, password_hash, role, uuid, created_at, updated_at)
    VALUES (:email, :nickname, :passwordHash, CAST(:role AS user_role), :uuid, :createdAt, :updatedAt)
    RETURNING *
    """, nativeQuery = true)
User saveWithRole(...);  // ❌ 제거됨

// 개선된 코드
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
    boolean existsByNickname(String nickname);
    // ✅ 표준 JPA save() 메서드 사용
}
```

### 5단계: UserService 리팩토링
```java
// 기존 문제 코드
@Transactional
public User signUp(SignUpRequest request) {
    // 검증 로직...
    LocalDateTime now = LocalDateTime.now();
    return userRepository.saveWithRole(  // ❌ 커스텀 메서드 사용
        request.getEmail(),
        request.getNickname(),
        passwordEncoder.encode(request.getPassword()),
        "USER",
        UUID.randomUUID(),
        now,
        now
    );
}

// 개선된 코드
@Transactional
public User signUp(SignUpRequest request) {
    // 검증 로직...
    User user = new User();
    user.setEmail(request.getEmail());
    user.setNickname(request.getNickname());
    user.setPasswordHash(passwordEncoder.encode(request.getPassword()));
    // ✅ @PrePersist에서 uuid, role, timestamps 자동 설정
    
    return userRepository.save(user);  // ✅ 표준 JPA save() 사용
}
```

**개선 효과**:
- JPA 표준 방식 사용으로 안정성 향상
- Entity의 `@PrePersist` 어노테이션 활용
- 코드 복잡도 감소

### 6단계: Spring Security 설정 보완
```java
// SecurityConfig.java에 추가
.authorizeHttpRequests(auth -> auth
    .requestMatchers(
        "/api/auth/**", 
        "/actuator/**", 
        "/",
        "/api/health/**",            // ✅ 헬스체크 API 추가
        "/api/health-statistics/**",
        // ... 기타 엔드포인트들
    ).permitAll()
    .anyRequest().authenticated()
)
```

**목적**: 데이터베이스 연결 상태 확인을 위한 헬스체크 엔드포인트 허용

### 7단계: 데이터베이스 연결 테스트 엔드포인트 추가
```java
// HealthCheckController.java 개선
@RestController
@RequiredArgsConstructor
public class HealthCheckController {
    private final UserRepository userRepository;
    
    @GetMapping("/api/health/db")
    public Map<String, Object> dbHealthCheck() {
        try {
            long userCount = userRepository.count();  // ✅ DB 연결 테스트
            return Map.of(
                "status", "OK", 
                "database", "Connected",
                "userCount", userCount
            );
        } catch (Exception e) {
            return Map.of(
                "status", "ERROR", 
                "database", "Connection Failed",
                "error", e.getMessage()
            );
        }
    }
}
```

**기능**: 실시간 데이터베이스 연결 상태 및 사용자 수 확인

### 8단계: 로깅 레벨 강화
```yaml
# application.yml에 추가
logging:
  level:
    com.lifebit: DEBUG                    # ✅ 애플리케이션 로그
    org.springframework.web: DEBUG        # ✅ 웹 요청 로그
    org.springframework.security: DEBUG   # ✅ 보안 로그
    org.hibernate.SQL: DEBUG             # ✅ SQL 쿼리 로그
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE  # ✅ SQL 파라미터 로그
```

**효과**: 문제 발생 시 상세한 디버깅 정보 제공

---

## ✅ 해결 결과

### 1. 데이터베이스 연결 확인
```bash
# 테스트 결과
PS> Invoke-RestMethod -Uri "http://localhost:8080/api/health/db" -Method GET

userCount database  status
--------- --------  ------
        7 Connected OK
```

### 2. 사용자 데이터 확인
```sql
-- PostgreSQL에서 확인된 사용자 데이터
SELECT user_id, email, nickname, role FROM users;
/*
 user_id |     email      | nickname | role  
---------+----------------+----------+-------
       1 | admin@lifebit.com | 관리자 | ADMIN
       2 | user1@example.com | 홍길동 | USER
       3 | user2@example.com | 김철수 | USER
       4 | user3@example.com | 이영희 | USER
       5 | user4@example.com | 박지민 | USER
       6 | test@test.com  | testuser | USER
       7 | admin@test.com | admin    | ADMIN
*/
```

### 3. 테스트 계정 정보
```
테스트 사용자:
- 이메일: test@test.com
- 비밀번호: password
- 역할: USER

관리자 계정:
- 이메일: admin@test.com  
- 비밀번호: password
- 역할: ADMIN
```

---

## 🎯 성능 개선 효과

### Before (문제 상황)
- ❌ 로그인 시 400 에러 발생
- ❌ 데이터베이스 연결 불안정
- ❌ 사용자 데이터 접근 불가
- ❌ 디버깅 정보 부족

### After (해결 후)
- ✅ 로그인 정상 작동
- ✅ PostgreSQL 안정적 연결
- ✅ 7명 사용자 데이터 활용 가능
- ✅ 실시간 DB 상태 모니터링
- ✅ 상세한 로깅으로 문제 추적 가능

---

## 📚 학습된 교훈

### 1. **데이터베이스 환경 일관성의 중요성**
- 개발/테스트/운영 환경에서 동일한 DB 엔진 사용 필요
- 인메모리 DB는 테스트 목적으로만 사용

### 2. **JPA 표준 방식 준수**
- 커스텀 네이티브 쿼리보다 표준 JPA 방식 선호
- Entity 생명주기 어노테이션(`@PrePersist`, `@PreUpdate`) 적극 활용

### 3. **환경 변수 관리의 중요성**
- 모든 환경별 설정은 환경 변수로 분리
- `.env.example` 파일로 필요한 변수 문서화

### 4. **모니터링 엔드포인트의 필요성**
- 헬스체크 API로 실시간 상태 확인
- 적절한 로깅 레벨로 문제 추적 용이성 확보

---

## 🔮 향후 개선 방안

### 1. **데이터베이스 백업 및 복구 체계**
```bash
# 정기 백업 스크립트 예시
docker exec lifebit_postgres pg_dump -U lifebit_user lifebit_db > backup_$(date +%Y%m%d).sql
```

### 2. **환경별 프로파일 분리**
```yaml
# application-dev.yml (개발환경)
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/lifebit_dev
    
# application-prod.yml (운영환경)  
spring:
  datasource:
    url: jdbc:postgresql://prod-server:5432/lifebit_prod
```

### 3. **API 응답 표준화**
```java
// 표준 API 응답 형식
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private String timestamp;
}
```

### 4. **통합 테스트 환경 구축**
```java
@SpringBootTest
@Testcontainers
class AuthControllerIntegrationTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16");
    
    @Test
    void 로그인_성공_테스트() {
        // 통합 테스트 코드
    }
}
```

---

## 📞 문의 및 지원

- **기술 문의**: 개발팀
- **긴급 상황**: 시스템 관리자
- **문서 업데이트**: 2025-06-17

---

**✨ 이 문서는 향후 유사한 문제 발생 시 빠른 해결을 위한 참고 자료로 활용하시기 바랍니다.** 