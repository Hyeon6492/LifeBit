---
- name: Deploy LifeBit Application to AWS
  hosts: lifebit_servers
  become: yes
  vars:
    app_directory: /home/ubuntu/lifebit
    docker_compose_file: docker-compose.prod.yml
    
  tasks:
    - name: Wait for system to be ready
      wait_for_connection:
        delay: 10
        timeout: 300

    - name: Ensure unattended-upgrades is not running
      shell: |
        # unattended-upgrades 완전 중지
        systemctl stop unattended-upgrades.service || true
        systemctl disable unattended-upgrades.service || true
        pkill -f unattended-upgrade || true
        
        # apt 프로세스 정리
        pkill -f apt-get || true
        pkill -f dpkg || true
        
        # 잠시 대기
        sleep 5
        
        # lock 파일 강제 제거
        rm -f /var/lib/dpkg/lock-frontend || true
        rm -f /var/lib/dpkg/lock || true
        rm -f /var/lib/apt/lists/lock || true
        rm -f /var/cache/apt/archives/lock || true
        
        echo "APT cleanup completed"
      register: apt_cleanup
      changed_when: false
      ignore_errors: yes

    - name: Wait for apt locks to be available (with timeout)
      shell: |
        timeout=120  # 2분 타임아웃
        elapsed=0
        
        while [ $elapsed -lt $timeout ]; do
          if ! fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && \
             ! fuser /var/lib/apt/lists/lock >/dev/null 2>&1 && \
             ! fuser /var/cache/apt/archives/lock >/dev/null 2>&1; then
            echo "APT locks are available"
            exit 0
          fi
          echo "Waiting for apt locks... ($elapsed/$timeout seconds)"
          sleep 10
          elapsed=$((elapsed + 10))
        done
        
        # 타임아웃 시에도 계속 진행
        echo "Timeout reached, but continuing anyway"
        exit 0
      register: apt_lock_wait
      changed_when: false

    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600
      environment:
        DEBIAN_FRONTEND: noninteractive
      retries: 3
      delay: 10

    - name: Install additional required packages
      apt:
        name:
          - rsync
          - htop
          - vim
          - tree
          - jq
        state: present
      environment:
        DEBIAN_FRONTEND: noninteractive
      retries: 3
      delay: 10

    - name: Create application directory
      file:
        path: "{{ app_directory }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create uploads directory
      file:
        path: "{{ app_directory }}/uploads"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create application archive locally
      shell: |
        cd {{ playbook_dir }}/../../
        tar --exclude='.git' \
            --exclude='apps/*/node_modules' \
            --exclude='apps/*/target' \
            --exclude='apps/*/venv' \
            --exclude='.env' \
            --exclude='*.log' \
            --exclude='infrastructure/terraform/.terraform' \
            --exclude='infrastructure/terraform/terraform.tfstate*' \
            --exclude='infrastructure/ansible/inventory' \
            -czf /tmp/lifebit-app.tar.gz .
      delegate_to: localhost
      become: no
      when: not ansible_check_mode

    - name: Copy application archive to remote server
      copy:
        src: "/tmp/lifebit-app.tar.gz"
        dest: "/tmp/lifebit-app.tar.gz"
        mode: '0644'
      when: not ansible_check_mode

    - name: Extract application files
      unarchive:
        src: "/tmp/lifebit-app.tar.gz"
        dest: "{{ app_directory }}/"
        remote_src: yes
        owner: ubuntu
        group: ubuntu
      when: not ansible_check_mode

    - name: Clean up temporary files
      file:
        path: "/tmp/lifebit-app.tar.gz"
        state: absent
      when: not ansible_check_mode

    - name: Clean up local temporary archive
      file:
        path: "/tmp/lifebit-app.tar.gz"
        state: absent
      delegate_to: localhost
      become: no
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Set ownership of application files
      file:
        path: "{{ app_directory }}"
        owner: ubuntu
        group: ubuntu
        recurse: yes

    - name: Copy environment file
      template:
        src: prod.env.j2
        dest: "{{ app_directory }}/.env"
        owner: ubuntu
        group: ubuntu
        mode: '0600'

    - name: Stop existing containers (if any)
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} down
        else
          docker compose -f {{ docker_compose_file }} down
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Pull latest images
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} pull
        else
          docker compose -f {{ docker_compose_file }} pull
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Build and start services
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} up -d --build
        else
          docker compose -f {{ docker_compose_file }} up -d --build
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      when: not ansible_check_mode

    - name: Wait for PostgreSQL to be ready
      uri:
        url: "http://localhost:8080/actuator/health"
        method: GET
        status_code: [200, 503]
      register: health_check
      until: health_check.status == 200
      retries: 30
      delay: 10
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify Core API health
      uri:
        url: "http://localhost:8080/actuator/health"
        method: GET
      register: core_api_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify AI API health
      uri:
        url: "http://localhost:8001/health"
        method: GET
      register: ai_api_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify Frontend
      uri:
        url: "http://localhost:3000"
        method: GET
      register: frontend_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Set default health status for check mode
      set_fact:
        core_api_health: { status: 0 }
        ai_api_health: { status: 0 }
        frontend_health: { status: 0 }
      when: ansible_check_mode

    - name: Display service status
      debug:
        msg:
          - "=== LifeBit 배포 상태 ==="
          - "Core API (Spring Boot): {{ 'OK' if core_api_health.status == 200 else 'FAILED' }}"
          - "AI API (FastAPI): {{ 'OK' if ai_api_health.status == 200 else 'FAILED' }}"
          - "Frontend (React): {{ 'OK' if frontend_health.status == 200 else 'FAILED' }}"
          - ""
          - "=== 접속 URL ==="
          - "Frontend: http://{{ ansible_host }}:3000"
          - "Core API: http://{{ ansible_host }}:8080"
          - "AI API: http://{{ ansible_host }}:8001"
          - "Nginx (통합): http://{{ ansible_host }}"

    - name: Show container status
      shell: docker ps --format "table {%raw%}{{.Names}}\t{{.Status}}\t{{.Ports}}{%endraw%}"
      become_user: ubuntu
      register: container_status
      when: not ansible_check_mode

    - name: Set default container status for check mode
      set_fact:
        container_status: { stdout_lines: ["No containers running (check mode)"] }
      when: ansible_check_mode

    - name: Display container status
      debug:
        msg: "{{ container_status.stdout_lines }}"

    - name: Create deployment info file
      copy:
        content: |
          # LifeBit 배포 정보
          배포 시간: {{ ansible_date_time.iso8601 }}
          서버 IP: {{ ansible_host }}
          
          # 서비스 URL
          Frontend: http://{{ ansible_host }}:3000
          Core API: http://{{ ansible_host }}:8080
          AI API: http://{{ ansible_host }}:8001
          Nginx: http://{{ ansible_host }}
          
          # 서비스 상태
          Core API: {{ 'OK' if core_api_health.status == 200 else 'FAILED' }}
          AI API: {{ 'OK' if ai_api_health.status == 200 else 'FAILED' }}
          Frontend: {{ 'OK' if frontend_health.status == 200 else 'FAILED' }}
        dest: "{{ app_directory }}/deployment_info.txt"
        owner: ubuntu
        group: ubuntu
        mode: '0644' 