---
- name: Deploy LifeBit Application to AWS
  hosts: lifebit_servers
  become: yes
  vars:
    app_directory: /home/ubuntu/lifebit
    docker_compose_file: docker-compose.prod.yml
    
  tasks:
    - name: Wait for system to be ready
      wait_for_connection:
        delay: 10
        timeout: 300

    - name: Verify user_data completion
      stat:
        path: /home/ubuntu/.user-data-completed
      register: user_data_status

    - name: Fail if user_data not completed
      fail:
        msg: "User data script has not completed. Please wait or run fix-unattended-upgrades.sh"
      when: not user_data_status.stat.exists

    - name: Update apt cache (if needed)
      apt:
        update_cache: yes
        cache_valid_time: 3600
      environment:
        DEBIAN_FRONTEND: noninteractive
      retries: 2
      delay: 5

    - name: Verify required packages are installed
      package_facts:
        manager: auto

    - name: Install missing packages (if any)
      apt:
        name:
          - rsync
          - htop
          - vim
          - tree
          - jq
        state: present
      environment:
        DEBIAN_FRONTEND: noninteractive
      when: "'jq' not in ansible_facts.packages or 'rsync' not in ansible_facts.packages"
      retries: 2
      delay: 5
      ignore_errors: yes

    - name: Create application directory
      file:
        path: "{{ app_directory }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create uploads directory
      file:
        path: "{{ app_directory }}/uploads"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create application archive locally
      shell: |
        cd {{ playbook_dir }}/../../
        tar --exclude='.git' \
            --exclude='apps/*/node_modules' \
            --exclude='apps/*/target' \
            --exclude='apps/*/venv' \
            --exclude='.env' \
            --exclude='*.log' \
            --exclude='infrastructure/terraform/.terraform' \
            --exclude='infrastructure/terraform/terraform.tfstate*' \
            --exclude='infrastructure/ansible/inventory' \
            -czf /tmp/lifebit-app.tar.gz .
      delegate_to: localhost
      become: no
      when: not ansible_check_mode

    - name: Copy application archive to remote server
      copy:
        src: "/tmp/lifebit-app.tar.gz"
        dest: "/tmp/lifebit-app.tar.gz"
        mode: '0644'
      when: not ansible_check_mode

    - name: Extract application files
      unarchive:
        src: "/tmp/lifebit-app.tar.gz"
        dest: "{{ app_directory }}/"
        remote_src: yes
        owner: ubuntu
        group: ubuntu
      when: not ansible_check_mode

    - name: Clean up temporary files
      file:
        path: "/tmp/lifebit-app.tar.gz"
        state: absent
      when: not ansible_check_mode

    - name: Clean up local temporary archive
      file:
        path: "/tmp/lifebit-app.tar.gz"
        state: absent
      delegate_to: localhost
      become: no
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Set ownership of application files
      file:
        path: "{{ app_directory }}"
        owner: ubuntu
        group: ubuntu
        recurse: yes

    - name: Verify Docker is running
      service:
        name: docker
        state: started
        enabled: yes

    - name: Verify Docker Compose is available
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          echo "docker-compose available"
        elif command -v docker compose >/dev/null 2>&1; then
          echo "docker compose available"
        else
          echo "No Docker Compose found"
          exit 1
        fi
      register: docker_compose_check
      changed_when: false

    - name: Check disk space
      shell: df -h / | awk 'NR==2 {print $4}' | sed 's/G//'
      register: disk_space
      changed_when: false

    - name: Warn if low disk space
      debug:
        msg: "Warning: Low disk space ({{ disk_space.stdout }}GB available). Consider upgrading instance type."
      when: disk_space.stdout | int < 5

    - name: Copy environment file
      template:
        src: prod.env.j2
        dest: "{{ app_directory }}/.env"
        owner: ubuntu
        group: ubuntu
        mode: '0600'

    - name: Stop existing containers (if any)
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} down
        else
          docker compose -f {{ docker_compose_file }} down
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Pull latest images
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} pull
        else
          docker compose -f {{ docker_compose_file }} pull
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Ensure letsencrypt directory exists
      file:
        path: /etc/letsencrypt
        state: directory
        owner: root
        group: root
        mode: '0755'
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Wait for DNS propagation (max 10 min, check every 15s)
      shell: |
        timeout=600
        interval=15
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          ip=$(dig +short {{ domain_name }} | tail -n1)
          if [ "$ip" = "{{ ansible_host }}" ]; then
            echo "DNS propagation complete: $ip"
            exit 0
          fi
          echo "Waiting for DNS propagation... ($elapsed/$timeout seconds, current: $ip)"
          sleep $interval
          elapsed=$((elapsed + interval))
        done
        echo "DNS propagation timeout"
        exit 1
      register: dns_check
      changed_when: false
      failed_when: dns_check.rc != 0
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Install certbot (standalone)
      apt:
        name: certbot
        state: present
        update_cache: yes
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Generate SSL certificate with Certbot (standalone)
      shell: |
        certbot certonly --standalone --non-interactive --agree-tos \
          --email admin@{{ domain_name }} -d {{ domain_name }}
      args:
        creates: "/etc/letsencrypt/live/{{ domain_name }}/fullchain.pem"
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Check if SSL certificate exists
      stat:
        path: "/etc/letsencrypt/live/{{ domain_name }}/fullchain.pem"
      register: ssl_cert_exists
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Copy letsencrypt to app directory
      synchronize:
        src: /etc/letsencrypt/
        dest: "{{ app_directory }}/letsencrypt/"
        recursive: yes
      when: domain_name is defined and domain_name != ansible_host and domain_name != "" and ssl_cert_exists.stat.exists

    - name: Build and start services
      shell: |
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f {{ docker_compose_file }} up -d --build
        else
          docker compose -f {{ docker_compose_file }} up -d --build
        fi
      args:
        chdir: "{{ app_directory }}"
      become_user: ubuntu
      when: not ansible_check_mode
      register: docker_start

    - name: Wait for PostgreSQL to be ready
      shell: |
        timeout=300
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          if docker exec lifebit_postgres_prod pg_isready -U lifebit_user -d lifebit_db >/dev/null 2>&1; then
            echo "PostgreSQL is ready"
            exit 0
          fi
          echo "Waiting for PostgreSQL... ($elapsed/$timeout seconds)"
          sleep 5
          elapsed=$((elapsed + 5))
        done
        echo "PostgreSQL readiness timeout"
        exit 1
      when: not ansible_check_mode and docker_start is succeeded

    - name: Verify database initialization
      shell: |
        docker exec lifebit_postgres_prod psql -U lifebit_user -d lifebit_db -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE';" | grep -o '[0-9]\+' | head -1
      register: table_count
      when: not ansible_check_mode and docker_start is succeeded

    - name: Check if database has required tables
      fail:
        msg: "Database initialization failed. Expected at least 14 tables, found {{ table_count.stdout }}"
      when: not ansible_check_mode and docker_start is succeeded and (table_count.stdout | int) < 14

    - name: Wait for containers to stabilize
      pause:
        seconds: 45
      when: not ansible_check_mode and docker_start is succeeded

    - name: Wait for Core API to be ready
      uri:
        url: "http://localhost:8080/actuator/health"
        method: GET
        status_code: [200, 503]
      register: health_check
      until: health_check.status == 200
      retries: 25
      delay: 15
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Check Core API database connectivity
      uri:
        url: "http://localhost:8080/actuator/health/db"
        method: GET
        status_code: [200, 503]
      register: db_health_check
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify Core API health
      uri:
        url: "http://localhost:8080/actuator/health"
        method: GET
      register: core_api_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify AI API health
      uri:
        url: "http://localhost:8001/health"
        method: GET
      register: ai_api_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Verify Frontend
      uri:
        url: "http://localhost:3000"
        method: GET
      register: frontend_health
      ignore_errors: yes
      when: not ansible_check_mode

    - name: Set default health status for check mode
      set_fact:
        core_api_health: { status: 0 }
        ai_api_health: { status: 0 }
        frontend_health: { status: 0 }
      when: ansible_check_mode

    - name: Display service status
      debug:
        msg:
          - "=== LifeBit 배포 상태 ==="
          - "Core API (Spring Boot): {{ 'OK' if (core_api_health.status is defined and core_api_health.status == 200) else 'FAILED' }}"
          - "AI API (FastAPI): {{ 'OK' if (ai_api_health.status is defined and ai_api_health.status == 200) else 'FAILED' }}"
          - "Frontend (React): {{ 'OK' if (frontend_health.status is defined and frontend_health.status == 200) else 'FAILED' }}"
          - ""
          - "=== 접속 URL ==="
          - "Frontend: http://{{ ansible_host }}:3000"
          - "Core API: http://{{ ansible_host }}:8080"
          - "AI API: http://{{ ansible_host }}:8001"
          - "Nginx (통합): http://{{ ansible_host }}"

    - name: Show container status
      shell: docker ps --format "table {%raw%}{{.Names}}\t{{.Status}}\t{{.Ports}}{%endraw%}"
      become_user: ubuntu
      register: container_status
      when: not ansible_check_mode

    - name: Set default container status for check mode
      set_fact:
        container_status: { stdout_lines: ["No containers running (check mode)"] }
      when: ansible_check_mode

    - name: Display container status
      debug:
        msg: "{{ container_status.stdout_lines }}"

    - name: Setup SSL certificate auto-renewal cron job
      cron:
        name: "Certbot SSL renewal"
        minute: "0"
        hour: "12"
        job: "/usr/bin/certbot renew --quiet"
        user: root
      when: domain_name is defined and domain_name != ansible_host and domain_name != ""

    - name: Create deployment info file
      copy:
        content: |
          # LifeBit 배포 정보
          배포 시간: {{ ansible_date_time.iso8601 }}
          서버 IP: {{ ansible_host }}
          {% if domain_name is defined and domain_name != ansible_host and domain_name != "" %}
          도메인: {{ domain_name }}
          SSL 인증서: {{ 'OK' if ssl_cert_exists.stat.exists or (certbot_result is defined and certbot_result.rc == 0) else 'FAILED' }}
          {% endif %}
          
          # 서비스 URL
          {% if domain_name is defined and domain_name != ansible_host and domain_name != "" %}
          Frontend: https://{{ domain_name }}
          Core API: https://{{ domain_name }}/api
          AI API: https://{{ domain_name }}/ai-api
          {% else %}
          Frontend: http://{{ ansible_host }}:3000
          Core API: http://{{ ansible_host }}:8080
          AI API: http://{{ ansible_host }}:8001
          Nginx: http://{{ ansible_host }}
          {% endif %}
          
          # 서비스 상태
          Core API: {{ 'OK' if (core_api_health.status is defined and core_api_health.status == 200) else 'FAILED' }}
          AI API: {{ 'OK' if (ai_api_health.status is defined and ai_api_health.status == 200) else 'FAILED' }}
          Frontend: {{ 'OK' if (frontend_health.status is defined and frontend_health.status == 200) else 'FAILED' }}
        dest: "{{ app_directory }}/deployment_info.txt"
        owner: ubuntu
        group: ubuntu
        mode: '0644' 